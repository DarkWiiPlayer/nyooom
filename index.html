<html theme=dark>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">

	<script type="importmap">
		{
			"imports": {
				"nyooom/render": "https://cdn.jsdelivr.net/gh/darkwiiplayer/nyooom@514648f/render.js",
				"nyooom/observable": "https://cdn.jsdelivr.net/gh/darkwiiplayer/nyooom@514648f/observable.js",
				"nyooom/domProxy": "https://cdn.jsdelivr.net/gh/darkwiiplayer/nyooom@514648f/domProxy.js",
				"nyooom/showcase": "./js/nyooom-showcase.js"
			}
		}
	</script>

	<script type="module" src="https://cdn.jsdelivr.net/gh/darkwiiplayer/components@master/TypeWriter.js"></script>

	<style>
		@import
		url('https://cdn.jsdelivr.net/gh/darkwiiplayer/css@71ab804/all.css') layer(framework);
		@import url('styles.css') layer(site);

		.jsdelivr-badge {
			filter: saturate(.4) hue-rotate(250deg);
			border-radius: .2em;
		}
	</style>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">

	<script>
		const scrollHook = () => {
			document.body.setAttribute("scroll", window.scrollY)
		}
		window.addEventListener("scroll", scrollHook)
		document.addEventListener("readystatechange", scrollHook)

		const observer = new IntersectionObserver(events => {}, {
			rootMargin: '-1px 0px 0px 0px',
			threshold: [1]
		})
	</script>

	<script type="module">
		import hljs from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/es/highlight.min.js';
		import lang_html from "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/es/languages/xml.min.js"

		hljs.registerLanguage("html", lang_html)

		document.querySelectorAll('code[lang="js"]').forEach(code => {
			code.innerHTML = hljs.highlight("javascript", code.innerText).value
		})
	</script>

	<script type="module">
		import "nyooom/showcase"
	</script>

	<a name=top></a>

	<header role="navigation" class="fixed">
		<nav class="bar">
			<ul>
				<li><a href="#top">Top</a></li>
				<li><a href="https://git.but.gay/darkwiiplayer/nyooom">Git</a></li>
				<li><a href="https://github.com/darkwiiplayer/nyooom">Github</a></li>
				<li><a href="https://www.npmjs.com/package/nyooom">npm</a></li>
			</ul>
		</nav>
		<img alt="" class="jsdelivr-badge" src="https://data.jsdelivr.com/v1/package/npm/nyooom/badge">
	</header>

	<page-hero role="banner" cover=60>
		<!-- <img src="https://picsum.photos/1920/1080"> -->
		<hgroup>
			<h1 style="font-size: 6vw">Nyooom</span></h1>
			<code lang="js">import { html } from "nyooom/render"</code>
			<p>
				A new way of building
				<type-writer loop>
					<span>HTML</span>
					<template>SVG</template>
					<template>templates</template>
					<template>components</template>
					<template>applications</template>
				</type-writer>
				in vanilla JavaScript
			</p>
		</hgroup>
		<flex-row gap=1>
			<!--<a class="button" href="#elevator-pitch">Elevator Pitch</a>-->
			<a class="button" href="#getting-started">Get Started</a>
		</flex-row>
	</page-hero>

	<main style="margin-top: 0">
		<section id="elevator-pitch" class="box">
			<div class="content-width" style="padding: 2em 0">
				<h2>Elevator Pitch</h2>

				<p class="big">
					Nyooom provides <em>easy</em> yet <em>powerful</em> HTML generation with optional <em>reactivity</em>, with the following priorities:
				</p>

				<ul class="big">
					<li> <b>Small & independent modules</b> that can be used separately
					<li> <b>Gradual adoption</b> without requiring full application rewrites
					<li> <b>Minimal abstraction</b> over native browser APIs
					<li> <b>Extensibility</b> for custom use cases
				</ul>

				<nyooom-showcase preview=false>
<code><div contenteditable="false">return html.p(
	"Text Node",
	html.br(),
	html.b("HTML Node"),
	{style:{color:"salmon"}},
)</div></code>
				</nyooom-showcase>

				<vertical-spacer></vertical-spacer>

				<p class="big">
					If that sounds good, it's time to <b>back up those claims</b>!<br>
					Keep scrolling to see how it works.
				</p>
			</div>
		</section>

		<section id="getting-started" class="content-width">
			<h2>Getting Started</h2>

			<section>
				<p>
					Trying out nyooom is super easy:
				</p>

				<pre class="box"><code lang=js>import {html} from "https://cdn.jsdelivr.net/npm/nyooom/nyooom.js"</code></pre>
				
				<p>Or, if you want to use <a href="#importmaps-snippet">import maps</a>:</p>

				<pre class="box"><code lang=js>import {html} from "nyooom/nyooom"</code></pre>
			</section>

			<section>
				<p>
					Calling any method on the <code>html</code> export will generate an HTML node.<br>
					Passing in arguments is how you add children, set attributes and even do more advanced things.
				</p>

				<nyooom-showcase preview="false">
					<code>
						<div contenteditable="false">return html.div("content")</div>
					</code>
				</nyooom-showcase>

				<p>
					Using the <code>component</code> helper from the <code>nyooom/observable</code> module
					makes it easier to see results on your page:
					Just pass it a function that returns some DOM nodes, and it'll register a custom element for you.
				</p>

				<pre class="box"><code lang=js>import {component} from "nyooom/observable"
const myComponent = () =&gt; html.div("Rendered Component")
component(myComponent) //Registers it as &lt;my-component&gt;</code></pre>

				<p>
					Of course, you can also just call <code lang=js>document.body.append(html.span("My Text"))</code> in your script.
				</p>

				<p>And if you'd like to use <code>importmaps</code> to de-clutter your code, here's a convenient template:</p>

<pre class="box" id="importmaps-snippet"><code lang="html">&lt;script type="importmap"&gt;
	{
		"imports": {
			"nyooom/render": "https://cdn.jsdelivr.net/npm/nyooom/render.js",
			"nyooom/observable": "https://cdn.jsdelivr.net/npm/nyooom/observable.js",
			"nyooom/domProxy": "https://cdn.jsdelivr.net/npm/nyooom/domProxy.js",
		}
	}
&lt;/script&gt;</code></pre>
			</section>

			<p>Alternatively, you can use this JSFiddle as a playground</p>
			<script async src="//jsfiddle.net/darkwiiplayer/cg5orayp/73/embed/js,result/dark/"></script>
		</section>

		<section class="content-width">
			<h2>Basic DOM generation</h2>

			<section>
				<p>
					Content can be added to a node by simply passing it as arguments to the function.
					This works for strings, HTML elements, functions and even observable state containers.
				</p>

				<nyooom-showcase preview="false">
					<code>
<div contenteditable="false">return html.span(
	"Nyooom ",
	html.u(
		"is ",
		html.b("cool")
	)
)</div>
					</code>
				</nyooom-showcase>
			</section>

			<section>
				<p>
					Adding attributes is just as easy: Just pass an object into the function.
					If the value is an array, it'll get joined with spaces.
				</p>

				<nyooom-showcase preview="false">
					<code>
<div contenteditable="false">return html.span({
	id: "warning",
	class: ["danger", "bold"],
})</div>
					</code>
				</nyooom-showcase>
			</section>

			<section>
				<p>
					Event listeners work just like attribute, except the value is a function:
				</p>

				<nyooom-showcase code="false">
					<code>
<div contenteditable="false">return html.button("Click Me!", {
	click: event => {
		alert("Button clicked :3")
	}
})</div>
					</code>
				</nyooom-showcase>

				<section>
					<p class="big">
						Some "attributes" are handled in special ways to make things easier:
					</p>

					<p>
						<code>style</code> sets the inline styles of the node.
					</p>
					<p>
						<code>camelCase</code> names will be converted to <code>kebab-case</code> and values
						will be converted to strings.
					</p>

					<nyooom-showcase>
						<code>
<div contenteditable="false">return html.div(
	{ style: {
		color: "salmon"
	}},
	html.span("Big Salmon",
		{ style: {
			fontSize: "1.4em"
		}}
	)
)</div>
						</code>
					</nyooom-showcase>

					<p>
						<code>dataset</code> converts its key-value pairs into <code>data-</code> attributes.
					</p>

					<nyooom-showcase preview=false>
						<code>
<div contenteditable="false">return html.span(
	{ dataset: {
		from: "Fire",
		to: "Heat",
		snakeCase: "converted"
	} },
	"Heat from Fire"
)</div>
						</code>
					</nyooom-showcase>

					<p>
						<code>shadowRoot</code> will attach a shadow DOM to the newly created node.
					</p>

					<nyooom-showcase code=false>
						<code>
<div contenteditable="false">return html.div(
	{ shadowRoot: [
		html.p("Shadow DOM text"),
		"Arrays work too :)"
	]},
	"Light DOM text"
)</div>
						</code>
					</nyooom-showcase>
				</section>
			</section>
		</section>

		<section class="content-width">

			<h2>It's just JavaScript</h2>

			<p>Nyooom is entirely implemented as a light-weight JavaScript library.</p>

			<p>
				This means that there is no new syntax for things you already know how to do.
				Functions like <code>filter</code> or <code>map</code> can be applied directly to your data,
				nodes can be assigned to variables right as you create them,
				common structures can be extracted into function and even passed around as arguments,
				and the syntax is just the boring old javascript that most tools already understand.
			</p>

			<nyooom-showcase code="false">
				<code>
<div contenteditable="false">return html.ul(
	["u", "b", "i"].map(
		type =&gt; html.li(html[type](
			`&lt;${type}&gt; element`
		))
	)
)</div>
				</code>
			</nyooom-showcase>
		</section>

		<section class="content-width">
			<h2>State changes in Nyooom</h2>

			<pre class="box"><code lang=js>import {Observable, State} from 'nyooom/observable'</code></pre>

			<p>
				Nyooom offers two types of state containers: States and Observables.
				Their purpose is to store one or more values and emit events when they are changed.
			</p>

			<p>
				The <code>render.js</code> library handles <code>State</code>s by setting DOM nodes up to
				get updated when the observable emits a change event. Neihter module depends on the other
				and they use a common protocol to work together.
			</p>

			<nyooom-showcase code="false">
				<code>
<div contenteditable="false">const counter = State.value(0)

return html.buttonGroup(
	html.button(
		"Click Me!",
		html.span(
			counter.compute(val =&gt; val ? ` ${val}` : "")
		),
		{
			click() {
				counter.value += 1
			}
		}
	),
	html.button(
		"Clear", {
			click() {
				counter.value = 0
			}
		}
	)
)</div>
				</code>
			</nyooom-showcase>
		</section>

		<section class="content-width">

			<h2>Obligatory Todo list</h2>

			<p>
				This simple ToDo component uses nothing more than Nyooom and
				the stylesheets already on this page to save some boilerplate.
			</p>

			<nyooom-showcase code="false">
				<code>
<div contenteditable="false">const task = value => 
html.flexRow (
	{class: "todo", gap: 1},
	value,
	html.span("[x]", {
		style: {
			color: "var(--primary-6)",
			cursor: "pointer"
		},
		click(event) {
			event
				.target
				.closest(".todo")
				.remove()
		}
	})
)
let todo, input
return todo = html.flexColumn(
	{gap: 1},
	input = html.input({
		type: "text",
		placeholder:
			"Do some stuff",
	}),
	html.button("Add Task",
	{
		click() {
			todo.append(task(
				input.value ||
				input.placeholder
			))
		}
	})
)</div>
				</code>
			</nyooom-showcase>

<p>And here, just for fun, the same thing but using <code>DomProxy.domArray</code> to handle the list.</p>

			<nyooom-showcase code="false">
				<code>
<div contenteditable="false">
const TaskList = domArray({
	new(text) {
		return html.li(text, html.button({
			class: "close",
			click({target}) { target.closest("li").remove() }
		}))
	},
	get() { return this.innerText }
})

const list = html.ul()
const todo = TaskList(list)

todo.push("Start using nyooom")

let input
return html.flexColumn(
	{gap: 1},
	input = html.input({
		type: "text",
		placeholder:
			"Do some stuff",
	}),
	html.button("Add Task", {
		click() {
			todo.push(input.value || input.placeholder)
		}
	}),
	list,
	html.button("Show List", {
		click() {
			alert(todo.map(t => `- ${t}`).join("\n"))
		}
	})
)</div>
				</code>
			</nyooom-showcase>
		</section>

		<section id="nyooom-explained" class="content-width">
			<h2>Nyooom Explained</h2>

			<h3>A bit of boring history</h3>

			<p>
				The <code>nyooom/render.js</code> module traces its basic idea back to a <a href="https://github.com/darkwiiplayer/skooma">Lua module</a>.
				The basic mechanism is the exact same, as the languages are very similar;
				with the noteable difference that the Lua version outputs text and uses a very
				lightweight DOM-like data-structure as an intermediary representation.
			</p>

			<p>
				Porting the library code to JavaScript was an obvious choice, given how similar both
				languages are in how they handle functions and metaprogramming.
				The concept worked well to generate HTML to send to the client,
				so it would work equally well to generate DOM nodes directly in the browser.
				And the obvious advantages over a server-side implementation is that things like event listeners could be attached directly.
			</p>

			<p>
				One design goal while further expanding the capabilities of nyooom has been to preserve this original use-case.
				The library is <i>small enough</i> that pulling it into a project just to generate a few nested DOM structures
				here and there isn't an unjustifiable waste of application size.
				This is also why the <code>render</code> module does not depend on the <code>observable</code>
				module, and has as little code as it can get away with to enable interoperability.
			</p>

			<p>
				The later addition of the <code>Obervable</code> module, and the ability of nyooom to detect state objects and
				handle them specially to enable reactivity is what truly enables the library to be used on its own to build
				simple and even moderately complex interactive components.
				<br>
				And with most of this extra complexity existing in a separate file,
				the size impact on the core nyooom library is very minimal, when
				reactivity is not wanted, or an alternative mechanism for reactivity
				is preferred.
			</p>

			<h3>Implementation</h3>

			<p>
				Nyooom is based on a convenient wrapper around <code>document.createElement</code>
				made even more convenient by a <code>Proxy</code> to generate & populate DOM nodes.
			</p>

			<h3>Rationale & design principles</h3>
			
			<p>
				The design of nyooom is based on the following assumption about web applications:
			</p>
			<blockquote>
				Most web application code can be modeled with simple abstractions.<br>
				The few cases that can't tend to be too complex for any general-purpose abstraction anyway.
			</blockquote>
			<p>
				Leading to a framework that focuses on the former group,
				while giving developers the tools to handle the tricky bits without having to hack themselves out of the framework first.
			</p>

			<p>
				One consideration that sets nyooom apart from other alternatives,
				is the emphasis on being both easy to adopt, integrate, and even abandon.
			</p>
			<p>
				While nyooom provides some level of abstraction over native browser APIs, everything done via nyooom is
				still easy to mentally map onto the underlying APIs. This reduces the mental load of translating what the
				code says, and what is happening to the website, creating a common mental model with vanilla javascript,
				as well as other non-magic libraries and micro-frameworks.
			</p>
			<p>
				This, in practice, means that adding some code that uses nyooom to an existing project, integrating it with
				other technologies, and even removing it in parts or in whole from a project that has outgrown it, or from performance-critical
				parts of an application that need even the last drop of performance squeezed out of the browser are all very
				simple to achieve.
			</p>
			<p>
				Even taking out certain aspects like reactivity, while still using nyooom to generate DOM nodes that get manipulated
				manually in response to complex state-changes is as easy as replacing the state objects with primitive values
				and writing the custom code to take their place.
			</p>
			<p>
				Where other frameworks suck in their stomach and do their best to fit every use-case you could have,
				nyooom is happy to just step aside and make space for more specialised tools.
				<!-- nyooom: the framework that promotes body-acceptance -->
			</p>
		</section>
	</main>

	<footer class="inset box">
		<flex-row gap=3>
			<table>
				<caption style="padding: 0">Feedback</caption>
				<tr>
					<th scope="col">Fediverse</th>
					<td><a href="https://tech.lgbt/@darkwiiplayer">@darkwiiplayer@tech.lgbt</a></td></tr>
			</table>
		</flex-row>
	</footer>
</htmlt>
